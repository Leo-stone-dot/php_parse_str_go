## 1 审计范围与方法
本次边界审计针对当前 Go 版 parse_str 的实现进行系统性检查，目标是对齐 PHP 语义并落实已明确的括号异常处理规则。审计覆盖 8 大类场景：分隔符与键值对、解码与鲁棒性、括号语法要点、混合容器语义、括号畸形细则、重复与覆盖规则、极端索引与深度、token 内的边缘解码。

> 关键边界规则（已达成共识）
> - 不匹配的 '[' → base 中的 '**'（如：a[=1 → a**）
> - 匹配对闭合后紧跟的多余 ']' 忽略（如：a[b]] → token 为 b）
> - 游离的 ']' 作为字面量保留在 base（如：b] → base 为 "b]")
> - 基本混合语义：a[b][c]=d & a[][d]=c → {"a":{"b":{"c":"d"},"0":{"d":"c"}}}

## 2 测试矩阵概览
- 分隔符与键值对：连续分隔符、尾部分隔符、分号与 '&' 混用、前导 '?'、无 '=' 的对（含 a[b]）

- 解码与鲁棒性：'+'→空格、百分号解码（含宽松模式）、Unicode 键值、解码后裁剪空白

- 括号语法要点：数组追加、数字洞、关联嵌套、按下一 token 推断子容器、标量→数组升级、在映射下的数字 token 与混合追加

- 混合容器语义：先映射后追加；先切片再数字索引后关联键（保持内容不丢失）

- 括号畸形细则：多余 ']'、游离 ']'、不匹配 '[' 转 '_'

- 重复与覆盖：纯标量最后写入生效；关联叶子最后写入生效；数组建立后遇纯标量（遵循 PHP：纯标量覆盖）

- 极端索引与深度：a[1000] 安全扩容；6 层以上深度稳定

- token 内边缘解码："a[%5D]=x"、"a[%5B]=y" 的 token 内括号按字面处理

**本次新增审计用例要点：**
- 分隔符/空段处理：a=1&&b=2，a=1;;b=2，尾部 &、;，混合 ';' 与 '&'。
- 无 '='：flag → ""；a[b] → 叶子空串。
- 解码与修正：bad=%ZZ（宽松保留），Unicode 键值，解码后裁剪空白。
- 畸形括号：a[b]]=1、b]=1、x]=1、a[b][=1、a[b]][][c]=x。

**混合容器语义覆盖：**
- a[b]=x → a[]=y → a[]=z → {"a":{"b":"x","0":"y","1":"z"}}
- a[]=x → a[2]=y → a[b]=z → 切片保留式转映射：{"a":{"0":"x","1":null,"2":"y","b":"z"}}
- 数字 token 在映射下按字符串键处理（不强制切片化）。

## 3 复现实例与关键行为
```go
// 分隔符与空段
parsephp.ParseStr("a=1&&b=2&") // → {"a":"1","b":"2"}
parsephp.ParseStr(";x=1;y=2&a=3") // → {"x":"1","y":"2","a":"3"}

// 无 '='
parsephp.ParseStr("flag")   // → {"flag":""}
parsephp.ParseStr("a[b]")   // → {"a":{"b":""}}

// 解码与鲁棒性
parsephp.ParseStr("q=%2B+%2520") // → {"q":"+ %20"}
parsephp.ParseStr("bad=%ZZ")     // → {"bad":"%ZZ"}
parsephp.ParseStr("城市=北京&k=%E4%B8%AD%E6%96%87") // → {"城市":"北京","k":"中文"}

// token 内的边缘解码（先分割 token，再分别解码）
parsephp.ParseStr("a[%5D]=x") // → {"a":{"]":"x"}}
parsephp.ParseStr("a[%5B]=y") // → {"a":{"[":"y"}}
```

> 解码顺序的关键修正：
> - 过去对整个键先解码再分割 token，可能将编码后的括号误判为结构边界。
> - 现调整为：先按原始字符串分割括号 token → 再分别对 base 和每个 token 执行解码与裁剪。
> - 这样 "a[%5D]" 的 token 内容会被解码为 "]" 并作为字面量键处理，不会触发错误的 "append" 语义。

## 4 主要结论（通过/修复/稳定性）
- 已通过：分隔符策略（含 ';'）、空段忽略、前导 '?'

- 已通过：无 '=' 的键（标量与括号叶子皆返回空串）

- 已通过：'+'→空格、宽松百分号解码、Unicode、解码后裁剪空白

- 已通过：数组追加、数字洞、关联嵌套、标量→数组升级

- 已通过：混合容器语义（映射下的追加按数字字符串键；切片保留式转换为映射）

- 已通过：括号畸形规则（不匹配 '[' → '_'；匹配对后多余 ']' 忽略；游离 ']' 保留）

- 已通过：极端索引与深度（1000 索引的切片扩容、6 层以上嵌套）

- 已修复：键的解码顺序（先 token 化后逐段解码），修复 token 内编码括号的误判问题

## 5 差异与易错点（简述）
- 在非叶子 append（token 为 ""）时，子容器类型由下一 token 决定：下一 token 为 ""/数字 → 切片；为非数字 → 映射。
    - 例如：a[b]][][c]=x → a["b"] 为切片，首元素为 {"c":"x"}；这与“在映射下以数字键追加”不同，但符合“按下一 token 推断子容器”的既定规则。

- 数字 token 在映射父容器下作为字符串键处理；不强制转换为切片，避免混合场景的内容丢失或类型震荡。

- 纯标量与数组混用：如 a[]=x 后续 a=Y，遵循 PHP 语义（最后写入覆盖），因此 a 的最终值为 "Y"；此点在测试中已明确并文档化。

## 6 测试与验证
- 新增审计测试文件：parsephp/parse_str_audit_test.go

- go vet 与 go test：均通过（包含原有测试与新增审计测试）

```go
// 执行命令
// 在项目根目录
// 结果：全部通过

go vet ./...
go test ./...
```

> 验证结论：当前实现与 PHP parse_str 语义保持一致，且落实了已明确的括号异常处理规则；新增的“token 内边缘解码”修正提高了稳定性与可预期性。

## 7 后续维护建议
- 增加基于属性的随机测试（property-based testing），覆盖更广泛的混合/畸形输入并与期望语义做对比

- 小规模 fuzz 语料，聚焦括号异常与编码异常的组合输入

- 对极端大索引的切片扩容设置可选上限或策略（例如转换为映射），以控制内存占用；但默认行为保持对齐 PHP 的“数字索引即数组”倾向

- 文档与示例中继续强调：
    - 键的解码顺序（先 token 化后逐段解码）
    - 畸形括号三条规则（'['→'_'；多余 ']' 忽略；游离 ']' 保留）
